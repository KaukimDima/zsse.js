<!--
Copyright (c) 2018, General Electric

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<link rel="import" href="../polymer/polymer.html"/>

<link rel="import" href="px-vis-behavior-common.html" />
<link rel="import" href="px-vis-behavior-d3.html" />

<script>
var PxVisBehaviorScale = window.PxVisBehaviorScale = (window.PxVisBehaviorScale || {});

/*
    Name:
    PxVisBehaviorScale.scale

    Description:
    Polymer behavior that provides some general properties

    Dependencies:
    - D3.js

    @polymerBehavior PxVisBehaviorScale.scale
*/
PxVisBehaviorScale.scale = [{
    /**
   * px-vis-extents-applied, fired when the calculated extents
   * (based on chartExtents/dataExtents) are actually applied
   * to the chart
   *
   * @event px-vis-extents-applied
   */
  properties: {
    /**
     * Holder for chart extents from the seriesConfig object
     *
     */
    _extents: {
      type: Array,
      value: function(){ return [[],[]] }
    },
    /**
     * Boolean to detect if the chart data has changed
     *
     */
    _chartDataHasChanged: {
      type: Number,
      value: 0
    },
    /**
     * Boolean to indicate if we are currently calculating the domain
     *
     */
    _calculatingDomain: {
      type: Boolean,
      value: false
    },
    /**
     * default extents to use if none are specified
     *
     * 0 for y axis for best practice
     *
     */
    _defaultScaleValue: {
      type: Object,
      value: function() {
        return {
          "x": [Infinity, -Infinity],
          "y": [Infinity, -Infinity]
        }
      }
    },

    /**
     * Defines if the viewable chart extents should update when chartData is updated
     *
     */
    disableDynamicUpdate: {
      type: Boolean,
      value: false
    },

    _runOnce: {
      type: Boolean,
      value: false
    },

    /**
     * Internal unique ID
     */
    chartId: {
      type: String
    },

    /**
     * The padding for ordinal type scales - effective controls the spacing between ordinal groups

     * Expressed as a percent of the ordinal group width, so a value of 0.5 for a bar chart means your bar and the gap between bars are the same size
     */
    scalePadding: {
      type: Number,
      value: 0.5
    },
    /**
     * The outer padding for ordinal type scales - effective controls the spacing between the first and last ordinal group the the axes

     * Expressed as a percent of the ordinal group width, so a value of 0.5 for a bar chart means your bar and the gap between bars are the same size
     */
     paddingOuter: {
      type: Number,
      value: 0.1
    },
    /**
     * The base for logarithmic type scales
     */
    logBase: {
      type: String,
      value: 10
    }
  },

  listeners: {
    'px-vis-request-pixel-for-data': '_pixelRequest'
  },

  _recreateScales: function(width, height, margin) {

    //prevent domain update
    this._calculatingDomain = true;

    if(this.x) {
      this._internalSetXScale(width, margin, true);
    }
    if(this.y) {
      if(this.isMultiY) {
        this._internalSetMultiYScale(height, margin, this.axes, true);
      } else {
        this._internalSetYScale(height, margin, true);
      }
    }

    this._calculatingDomain = false;
  },

  /**
   *  Sets the x scale or update its range if already existing
   *
   * @method _setXScale
   */
  _setXScale: function(width, margin) {
    if(this.hasUndefinedArguments(arguments)) {
      return;
    }
    this._internalSetXScale(width, margin, false);
  },
  _internalSetXScale: function(width, margin, forceRecreation) {
    var w = Math.max(width - margin.left - margin.right, 0);

    //create or update
    if(this.x && this.x._scaleType === this.xAxisType && !forceRecreation) {
      this.x.range([0,w]);

      //only update if it has been set already, the first set of domain
      //changed should come from extents
      if(this.domainChanged) {
        if(this._isOrdinalType(this.xAxisType)) {
          this._createOrdinalInvert(this.x, false);
        }

        this.set('domainChanged', this.domainChanged + 1);

      }
    } else {
      this.set('x', this._setScale(this.xAxisType,[0, w], this.x));
    }
  },

  /**
   * Sets the y scale or update its range if already existing
   *
   * @method _setYScale
   */
  _setYScale: function(height, margin) {
    if(this.hasUndefinedArguments(arguments)) {
      return;
    }
    this._internalSetYScale(height, margin, false);
  },
  _internalSetYScale: function(height, margin, forceRecreation) {
    var h = Math.max(height - margin.top - margin.bottom, 0);

    //create or update
    if(this.y && this.y._scaleType === this.yAxisType && !forceRecreation) {
      this.y.range([h, 0]);

      //only update if it has been set already, the first set of domain
      //changed should come from extents
      if(this.domainChanged) {
        if(this._isOrdinalType(this.yAxisType)) {
          this._createOrdinalInvert(this.y, true)
        }

        this.set('domainChanged', this.domainChanged + 1);

      }
    } else {
      this.set('y', this._setScale(this.yAxisType,[h, 0], this.y));
    }
  },

  /**
   * Sets a multi y scale
   *
   * @method _setYScale
   */
  _setMultiYScale: function(height, margin, axes) {
    if(this.hasUndefinedArguments(arguments)) {
      return;
    }
    this._internalSetMultiYScale(height, margin, axes, false);
  },
  _internalSetMultiYScale: function(height, margin, axes, forceRecreation) {
    var h = Math.max(height - margin.top - margin.bottom, 0),
        newY,
        copy,
        updated = false,
        created = false;

    if(!this.y) {
      copy = {};
    } else {
      copy = this.y;
    }

    //create or update
    for(var i = 0; i < this.axes.length; i++) {
      if(copy[this.axes[i]] && copy[this.axes[i]]._scaleType === this.yAxisType && !forceRecreation) {
        copy[this.axes[i]].range([h, 0]);
        updated = true;
      } else {
        newY = this._setScale(this.yAxisType,[h, 0], copy, true, this.axes[i]);
        copy[this.axes[i]] = newY;

        created = true;
      }
    }
    if(created) {
      this.set('y', copy);
    }
    if(updated) {
      //only update if it has been set already, the first set of domain
      //changed should come from extents
      if(this.domainChanged) {
        this.set('domainChanged', this.domainChanged + 1);
      }
    }
  },

  /**
   *  Helper function to set the x and y based on scale type
   *
   * @method _setScale
   */
  _setScale: function(type, range, currentAxis, isMultiAxis, key) {
    // TODO support more types: log, quantile, etc

    // FIXME This is somewhat silly; we recreate the scale every time b/c otherwise the observer wont rerun. Rethink this so we can just update range when necessary.
    var isMultiAxis = isMultiAxis || false,
        result;

    if(type === 'time') {
      result = Px.d3.scaleUtc().nice().range(range);
      result._scaleType = 'time';
    } else if(type === 'timeLocal') {
      result = Px.d3.scaleTime().nice().range(range);
      result._scaleType = 'timeLocal';
    } else if(type === 'linear') {
      result = Px.d3.scaleLinear().nice().range(range);
      result._scaleType = 'linear';
    } else if(type === 'log') {
      result = Px.d3.scaleLog().nice().base(this.logBase).range(range);
      result._scaleType = 'log';
    } else if(type === 'scaleBand') {
      result = Px.d3.scaleBand().range(range).round(true).paddingInner(this.scalePadding).paddingOuter(this.paddingOuter);
      result._scaleType = 'scaleBand';
    } else { //ordinal
      result = Px.d3.scalePoint().range(range).padding(this.scalePadding);
      result._scaleType = 'ordinal';
    }

    if(currentAxis && isMultiAxis && currentAxis[key]) {
      result.domain(currentAxis[key].domain());
    } else if(currentAxis && !isMultiAxis) {
      result.domain(currentAxis.domain());
    }

    return result;
  },

  /**
   * Calculates and Sets the x and y domain after data loads
   *
   * https://github.com/mbostock/d3/wiki/API-Reference
   *
   * @method _setDomain
   */
   _setDomain: function() {

    if(this.hasUndefinedArguments(arguments)) {
      return;
    }

    //we need to debounce because when we update completeSeriesConfig
    //then we set dataExtents and then completeSeriesConfig which
    //kicks this twice (and once with the wrong completeSeriesConfig)
    //we can probably remove the debounce once we have batch updates in
    //Polymer 2
    this.debounce('_setDomain', function() {

      // escape if we dont have everything we need
      if(this._calculatingDomain || this._isObjEmpty(this.chartData) || !this.x || !this.y || this._isObjEmpty(this.completeSeriesConfig)) {
        return
      }
      // indicate we are calculating the domain
      this._calculatingDomain = true;

      // Fallback if specified or we dont have an id
      if(!this.chartId || this.preventWebWorkerSynchronization ) {
        var extents = this._determineExtents();
        this._applyExtents(extents);

        // Ordinal scales do not have invert, so use quantizeScale to figure out ord value we are near
        if(this._isOrdinalType(this.xAxisType)) {
          this._createOrdinalInvert(this.x, false);
        }
        if(this._isOrdinalType(this.yAxisType)) {
          this._createOrdinalInvert(this.y, true)
        }

        return;
      }

      //get what info we need for the web worker to get our extents
      var wwInfo = {};

      wwInfo.xAxisType = this.xAxisType;
      wwInfo.yAxisType = this.yAxisType;
      wwInfo.completeSeriesConfig = this.completeSeriesConfig;
      wwInfo.chartExtents = this.chartExtents;
      wwInfo.dataExtents = this.dataExtents;
      wwInfo.axes = this.axes;
      wwInfo.seriesToAxes = this.seriesToAxes;
      wwInfo.isYAxisObject = typeof this.y === 'object';
      wwInfo.hardMute = this.hardMute;
      wwInfo.mutedSeries = this.mutedSeries;

      Px.vis.scheduler.process({
        'action': 'determineExtents',
        'originatorName': this.nodeName,
        'chartId': this.chartId,
        'data': wwInfo,
        'successCallback': function(e) {

          //if the chart has been detached while searching for extents
          //the results will be null
          if(e.data) {
            this._applyExtents(e.data);
          }
        }.bind(this)
      });
    }.bind(this), 10);
  },

  _createOrdinalInvert: function(scale, invert) {
    scale.invert = (function() {
      var dom = scale.domain(),
          r = scale.range(),
          domain = invert ? dom.reverse() : dom,
          range = invert ? [r[1],r[0]] : r,  //scaleQuantize REQUIRES ascending order range
          sq = Px.d3.scaleQuantize().domain(range).range(domain);

      return function(d) {
        return sq(d)
      }
    })();
  },

  _applyExtents: function(extents) {
    if(typeof this.y === 'object') {
      for(var i = 0; i < this.axes.length; i++){
        if(!this.y[this.axes[i]]) {
          continue;
        }

        // need to make sure 0 is not included in ext for log
        if(this.yAxisType === 'log') {
          extents.y[this.axes[i]] = this._fixLogExt(extents.y[this.axes[i]]);
        }

        if(this.matchTicks && !this.singleDomain) {
          var min = Math.floor(extents.y[this.axes[i]][0]/10)*10,
              max = Math.ceil(extents.y[this.axes[i]][1]/10)*10;

          this.y[this.axes[i]].domain([min,max]);

        } else {
          this.y[this.axes[i]].domain(extents.y[this.axes[i]]);

        }
      }

    } else {
      if(this.yAxisType === 'log') {
        extents.y = this._fixLogExt(extents.y);
      }
      this.y.domain(extents.y);
    }

    this.fire('px-vis-extents-applied', extents);

    if(this.xAxisType === 'log') {
      extents.x = this._fixLogExt(extents.x);
    }

    // if we are streaming data, dont keep updating x
    if(this.disableDynamicUpdate) {
      if(!this.runOnce) {
        this.x.domain(extents.x);
        this.set('domainChanged', this.domainChanged + 1);

        this.runOnce = true;
      }
    } else {
      this.x.domain(extents.x);
      this.set('domainChanged', this.domainChanged + 1);
    }

    this._calculatingDomain = false;
  },

  /**
   * Calculates the extents based on chartExtents, dataExtents, and the data.
   *
   */
  _determineExtents: function() {
    //check our axis types so we know if we are doing ordinal
    var xOrd = this._isOrdinalType(this.xAxisType),
        yOrd = this._isOrdinalType(this.yAxisType),
        // are we doing time?
        xTime = this._isTimeType(this.xAxisType),
        //doX if we are not doing time
        doX = xTime ? false : true,
        doY = true,
        keys = this._seriesKeys ? this._seriesKeys : Object.keys(this.completeSeriesConfig),
        //our extents starter
        extents = {
          'x': [],
          'y': []
        };

    // look at our chartExtents and dataExtents for values
    extents.x = this._checkForExtents(xOrd, this.chartExtents, this.dataExtents, "x");
    extents.y =  typeof this.y === 'object' ? this._calcMultiAxisExtents() : this._checkForExtents(yOrd, this.chartExtents, this.dataExtents, "y");

    //if our chart data has not changed, then dont go through all the data. Just use the extents we have
    if(extents.x.length > 0 && extents.x[0] !== Infinity && extents.x[1] !== -Infinity) {
      xTime = false;
      doX = false;
    }
    // if multiAxis, we calced in a different way, so dont calc again.
    if(!Array.isArray(extents.y) || (extents.y.length > 0 && extents.y[0] !== Infinity && extents.y[1] !== -Infinity)) {
      doY = false;
    }

    //if we have no chartData, dont look for new extents
    if(this.chartData.length === 0) {
      xTime = false;
      doX = false;
      doY = false;
    }

    //if we need, Chug through the data to max and min
    if(doX || doY || xTime) {
      this._findMinMax(this.chartData, doX, doY, xOrd, yOrd, xTime, extents, keys);
    }

    this._chartDataHasChanged = 0;

    // check that we found something for x
    if(extents.x[0] === Infinity) {
      extents.x[0] = 0;
    }
    if(extents.x[1] === -Infinity) {
      extents.x[1] = 1;
    }

    // check that we found something for y
    if(Array.isArray(extents.y) && extents.y[0] === Infinity) {
      extents.y[0] = 0;
    }
    if(Array.isArray(extents.y) && extents.y[1] === -Infinity) {
      extents.y[1] = 1;
    }

    //if min and max are the same widen the range by 1 so we still get a range and see the value
    if(extents.x[1] === extents.x[0]) {
      extents.x[0] -= 0.5;
      extents.x[1] += 0.5;
    }
    if(Array.isArray(extents.y)) {
      if(extents.y[1] === extents.y[0]) {
        extents.y[0] -= 0.5;
        extents.y[1] += 0.5;
      }
    } else {
      var yKeys = Object.keys(extents.y);

      for(var i=0; i<yKeys.length; i++) {
        if(extents.y[yKeys[i]][0] === extents.y[yKeys[i]][1]) {
          extents.y[yKeys[i]][0] -= 0.5;
          extents.y[yKeys[i]][1] += 0.5;
        }
      }
    }

    if(this.startFromZero) {
      if(this.xAxisType === 'linear') {
        extents.x[0] = Math.min(extents.x[0], 0);
        extents.x[1] = Math.max(extents.x[1], 0);
      }

      if(this.yAxisType === 'linear') {
        extents.y[0] = Math.min(extents.y[0], 0);
        extents.y[1] = Math.max(extents.y[1], 0);
      }
    }

    return extents
  },

  /**
   * Looks at chartExtents and dataExtents for extents values per axis
   *
   */
  _checkForExtents: function(isOrd, chartExtents, dataExtents, axis) {
    var exts = [];

    // if we are dealing with ordinal data
    if(isOrd) {
      // copy from dataExtents
      if(dataExtents && dataExtents[axis]) {
        //copy what was passed in
        exts = JSON.parse(JSON.stringify(dataExtents[axis]));
      }

      // overwrite with chartData if present
      if(chartExtents && chartExtents[axis]) {
        //copy what was passed in
        exts = JSON.parse(JSON.stringify(chartExtents[axis]));
      }

    //if we are dealing with time or linear
    } else {
      var fromChartExtents = false;
      exts = this._checkChartExtents(chartExtents, axis);

      //did we get extents from chartExtents?
      fromChartExtents = exts.length === 2 ? true : false;

      exts = this._checkDataExtents(dataExtents, chartExtents, axis, fromChartExtents, exts);

      // if nothing gets assigned, then stick in defaults
      if(exts.length < 2){
        //copy the default values
        exts = [ this._defaultScaleValue[axis][0], this._defaultScaleValue[axis][1] ];
      }
    }

    return exts
  },

  /**
   * Looks at chartExtents for extents values per axis
   *
   */
  _checkChartExtents: function(cExts, axis) {
    var exts = [];
    //if the dev specified extents, use them
    if(cExts && cExts[axis] && cExts[axis].length === 2) {
      exts[0] = (cExts[axis][0] === 'dynamic') ? Infinity : cExts[axis][0];
      exts[1] = (cExts[axis][1] === 'dynamic') ? -Infinity : cExts[axis][1];
    }
    return exts;
  },

  /**
   * Looks at dataExtents for extents values per axis; resolves chartExtents
   *
   */
  _checkDataExtents: function(dExts, cExts, axis, bool, exts) {
    var exts = exts || [];

    //if there are dataExtents, use them if they dont overwrite the chartExtents
    if(dExts && dExts[axis] && dExts[axis].length === 2) {
      // if we have chartExtents aready, figure out which to use
      if(bool) {
        exts[0] = (cExts[axis][0] === 'dynamic') ? dExts[axis][0] : cExts[axis][0];
        exts[1] = (cExts[axis][1] === 'dynamic') ? dExts[axis][1] : cExts[axis][1];

      } else {
        exts[0] = Math.min(dExts[axis][0], this._defaultScaleValue[axis][0]);
        exts[1] = Math.max(dExts[axis][1], this._defaultScaleValue[axis][1]);
      }
    }

    return exts;
  },

  /**
   *
   * Find the min and max values or ordinal values in data, for X and/or Y axis
   *
   */
  _findMinMax: function(data, doX, doY, ordX, ordY, timeX, result, keys) {
    var j,xVal,yVal,
      jLen = data.length,
      x = this.completeSeriesConfig[keys[0]].x,
      y = this.completeSeriesConfig[keys[0]].y,
      //check which individual parts need calculation
      doX0 = (!ordX && result.x[0] === Infinity) ? true : false,
      doX1 = (!ordX && result.x[1] === -Infinity) ? true : false,
      doY0 = (!ordY && result.y[0] === Infinity) ? true : false,
      doY1 = (!ordY && result.y[1] === -Infinity) ? true : false;

    if(timeX) {
      this._findTimeMM(result,data,jLen,x,doX0,doX1);
    }
    for(j = 0; j < jLen; j++) {
      //make sure we're dealing with numbers
      xVal = this._getDataExtents(data[j], keys, 'x');
      yVal = this._getDataExtents(data[j], keys, 'y');
      if(doX) {
        this._processDataValues(ordX, result, data, 'x', x, j, doX0, doX1, xVal[0], xVal[1]);
      }
      if(doY) {
        this._processDataValues(ordY, result, data, 'y', y, j, doY0, doY1, yVal[0], yVal[1]);
      }
    };
  },

  /**
   * Goes through the data and extracts min and max values
   *
   */
  _getDataExtents: function(d,keysArr, axis) {
    var a = [];
    for(var i = 0; i < keysArr.length; i++) {
      var key = keysArr[i];

      if(!this.mutedSeries[keysArr[i]]) {
        var val = d[this.completeSeriesConfig[key][axis]];

        if(val || val === 0) {
          a.push(val);
        }
      }
    }
    return [ Math.min.apply(null,a), Math.max.apply(null,a) ];
  },

  /**
   * Finds time based Max and Min
   *
   */
  _findTimeMM: function(result,d,l,x,doMin,doMax) {
    if(doMin) {
      this._setMin(result.x,d[0][x]);
    }
    if(doMax) {
      this._setMax(result.x,d[l-1][x]);
    }
  },

  /**
   * Compares existing min and new data for min
   *
   */
  _setMin: function(r,d) {
   if(isNaN(r[0]) || r[0] > d) {
      r[0] = d;
    }
  },

  /**
   * Compares existing max and new data for max
   *
   */
  _setMax: function(r,d) {
    if(isNaN(r[1]) || r[1] < d) {
      r[1] = d;
    }
  },

  /**
   * Goes through the values from the data and calcs the extents
   *
   */
  _processDataValues: function(isOrd, r, d, axis, key, i, doMin, doMax, v0, v1) {
    // if it is ordinal, push unique keys in
    if(isOrd) {
      if(r[axis].indexOf(d[i][key]) === -1) {

        r[axis].push(d[i][key]);
      }
    } else {
      // get the min and max values
      if(doMin) {
        this._setMin(r[axis],v0);
      }
      if(doMax) {
        this._setMax(r[axis],v1);
      }
    }
  },


/**
 * Loop through each series and see if it has mins and maxes in seriesConfig
 *
 */
_checkInSeriesConfig: function(exts, a) {
  for(var i = 0; i < this.seriesToAxes[a].length; i++) {
    var s = this.seriesToAxes[a][i];

    if(!this.hardMute || !this.mutedSeries[s]) {
      exts[a][0] = (this.completeSeriesConfig[s]['yMin'] || this.completeSeriesConfig[s]['yMin'] === 0) ?
          Math.min(this.completeSeriesConfig[s]['yMin'], exts[a][0]) : exts[a][0];

      exts[a][1] = (this.completeSeriesConfig[s]['yMax'] || this.completeSeriesConfig[s]['yMax'] === 0) ?
          Math.max(this.completeSeriesConfig[s]['yMax'], exts[a][1]) : exts[a][1];
    }
  }
},

/**
 * Apply chart extents
 *
 */
_applyChartExtents: function(exts, a) {
  // for backwards compatibility, if they dont specify an axis apply to all
  var k = this.chartExtents[a] ? a : 'y';

  if(this.chartExtents[k]) {

    if(this.chartExtents[k][0] === 'dynamic') {
      //if we got a value from seriesConfig, use it, otherwise Infinity
      exts[a][0] = exts[a][0] || exts[a][0] === 0 ? exts[a][0] : Infinity;
    } else {
      exts[a][0] = this.chartExtents[k][0];
    }


    if(this.chartExtents[k][1] === 'dynamic') {
      exts[a][1] = exts[a][1] || exts[a][1] === 0 ? exts[a][1] : -Infinity;
    } else {
      exts[a][1] = this.chartExtents[k][1];
    }

  }
},

/**
 * Search for multi axis extents
 *
 */
_searchForExtents: function (exts, seriesToSearch, data) {
  var seriesList = Object.keys(seriesToSearch);
  for(var i = 0; i < data.length; i++) {
    for(var j = 0; j < seriesList.length; j++) {
      var s = seriesList[j],
          sY = this.completeSeriesConfig[s]['y'],
          series = seriesToSearch[s],
          axis = series['axis'];
      if(series.min && (data[i][sY] || data[i][sY] === 0)) {
        exts[axis][0] = Math.min(data[i][sY], exts[axis][0]);
      }
      if(series.max && (data[i][sY] || data[i][sY] === 0)) {
        exts[axis][1] = Math.max(data[i][sY], exts[axis][1]);
      }
    }
  }
},

/**
 * Search for multi axis extents
 *
 */
_calcSeriesToSearch: function (exts, a, seriesToSearch) {
  for(var i = 0; i < this.seriesToAxes[a].length; i++) {
    var s = this.seriesToAxes[a][i];

    if(!this.hardMute || !this.mutedSeries[s]) {
      seriesToSearch[s] = {
        "axis": a,
        "min": exts[a][0] === Infinity ? true : false,
        "max": exts[a][1] === -Infinity ? true : false
      };
    }
  }
},

/**
 * calculates chart extents for multi axis
 *
 */
_calcMultiAxisExtents: function() {
  // TODO integrate this into the other calcs
  var search = false,
      exts = {},
      seriesToSearch = {},
      a,
      keys;

  for(var i = 0; i < this.axes.length; i++) {
    a = this.axes[i];
    exts[a] = [];
    exts[a][0] = this._defaultScaleValue.y[0];
    exts[a][1] = this._defaultScaleValue.y[1];

    // does it exist in the seriesConfig
    // need to look at each series instead of each axis
    this._checkInSeriesConfig(exts, a);

    // does it exist in chartExtents, if so, overwrite
    if(this.chartExtents) {
      this._applyChartExtents(exts, a);
    }

    // check if we need to search chartData for extents
    if(exts[a][0] === Infinity || exts[a][1] === -Infinity) {
      search = true;
      this._calcSeriesToSearch(exts, a, seriesToSearch);
    }
  }

  // if we indicated we need to search for extent values
  if(search) {
    this._searchForExtents(exts, seriesToSearch, this.chartData);
  }

  //verify all extents are valid
  keys = Object.keys(exts);
  for(var i=0; i<keys.length; i++) {
    if(exts[keys[i]][0] === Infinity || exts[keys[i]][1] === -Infinity) {
      exts[keys[i]] = [0,1];
    }
  }

  return exts;
},

  /**
   * When the domain gets set via a user interaction, set the scale function to use the new domain
   *
   * https://github.com/mbostock/d3/wiki/API-Reference
   *
   * @method _updateDomain
   */
  _updateDomain: function(selectedDomain) {
    if(this.hasUndefinedArguments(arguments)) {
      return;
    }
    if(this.x && this.y) {
      if(selectedDomain === 'reset' || selectedDomain === 'rereset') {
        this._setDomain();
      } else {
        //set new X domain if provided
        if(selectedDomain.x.length > 0) {
          this.x.domain(selectedDomain.x);
        }

        //set new Y domain if provided
        if(typeof this.y === 'object' && !Array.isArray(selectedDomain.y)) {
          for(var i = 0; i < this.axes.length; i++) {
            this.y[this.axes[i]].domain(selectedDomain.y[this.axes[i]]);
          }
        } else if(typeof this.y === 'function' && selectedDomain.y.length > 0) {
          this.y.domain(selectedDomain.y);
        }

        this.set('domainChanged', this.domainChanged + 1);
      }
    }
  },
  _chartDataChanged: function() {
    if(this.hasUndefinedArguments(arguments)) {
      return;
    }
    this.set('_chartDataHasChanged', this._chartDataHasChanged++);
  },

  _setAxisScale: function(leftDims, rightDims, leftAxisSize, rightAxisSize) {
    var leftDims = leftDims || [],
        rightDims = rightDims || [],
        allDims = leftDims.concat(rightDims),
        leftAxisSize = leftAxisSize || 50,
        rightAxisSize = rightAxisSize || 50;

    if(allDims.length === 0) {
      return
    }

    var s = function(d) {
      if(leftDims.indexOf(d) !== -1) {
        return leftDims.indexOf(d) * leftAxisSize * -1;
      } else if(rightDims.indexOf(d) !== -1) {
        return rightDims.indexOf(d) * rightAxisSize;
      }
    }

    s.domain = function() {
      return allDims;
    }

    s.leftDomain = function(newDims) {
      if(newDims) {
        leftDims = newDims;
      }
      return leftDims;
    }

    s.rightDomain = function(newDims) {
      if(newDims) {
        rightDims = newDims;
      }
      return rightDims;
    }

    return s;
  },

  /**
   * Gets pixel values for data values relating to a series (series is the id
   * used in seriesConfig). data is an array: [xValue, yValue]
   * if margin is specified it will use thos to adjust the pixel values
   * instead of the normal `margin` property
   * returns an object with the result and whether that result is out of
   * bounds for the current domain
   */
  getPixelFromData: function(data, series, margin) {
    var x,
        y,
        marg = margin ? margin : this.margin,
        outOfBounds = false,
        yDomain = this.y[this.completeSeriesConfig[series].axis.id].domain();

    if(data[0] < this.x.domain()[0] || data[0] > this.x.domain()[1] || data[1] < yDomain[0] || data[1] > yDomain[1]) {
      outOfBounds = true;
    }

    x = this.x(data[0]) + Number(marg.left);
    y = this.y[this.completeSeriesConfig[series].axis.id](data[1]) + marg.top;

    return {
      'pixel': [x, y],
      'outOfBounds': outOfBounds
    };
  },

  /**
   * Gets data values for pixel values relating to a series (series is the id
   * used in seriesConfig). pixelVal is an array: [xValue, yValue]
   * please note that the values returned have no guarantee to match any
   * actual chart data, this is just a conversion based on pixel
   */
  getDataFromPixel: function(pixelVal, series) {
    var x,
        y;

    x = this.x.invert(pixelVal[0]);
    y = this.y[this.completeSeriesConfig[series].axis.id].invert(pixelVal[1]);

    return [x, y];
  },

  _pixelRequest: function(evt) {
    var res = this.getPixelFromData(evt.detail.data, evt.detail.series, evt.detail.margin);
    evt.detail.callback(res);
  },

  _updatePadding: function() {
    var updated = false;

    if(this.xAxisType === 'scaleBand' && this.x && this.x.paddingInner) {
      this.x.paddingInner(this.scalePadding).paddingOuter(this.paddingOuter);
       updated = true;
    }

    if(this.yAxisType === 'scaleBand' && this.y && this.y.paddingInner) {
      this.y.paddingInner(this.scalePadding).paddingOuter(this.paddingOuter);
      updated = true;
    }

    if(updated && this.domainChanged) {
      this.set('domainChanged', this.domainChanged + 1);
    }
  },

  _updateLogBase: function() {
    var updated = false;
    if(this.xAxisType === 'log' && this.x && this.x.base) {
      this.x.base(this.logBase);
      updated = true;
    }

    if(this.yAxisType === 'log' && this.y) {
      if(typeof this.y === 'function') {
        this.y.base(this.logBase);
        updated = true;

      } else if(typeof this.y === 'object') {
        for(var i = 0; i < this.axes.length; i++) {
          if(this.y[this.axes[i]] && this.y[this.axes[i]].base) {
            // such depth, so pretty
            this.y[this.axes[i]].base(this.logBase);
          }
        }
        updated = true;

      }
    }
  },

  _fixLogExt: function(ext) {

    // Both are negative ==> check for 0
    if(ext[0] <= 0 && ext[1] <= 0) {
      ext[1] = ext[1] === 0 ? -1 : ext[1];

    // Both are positive ==> check for 0
    } else if(ext[0] >= 0 && ext[1] >= 0) {
      ext[0] = ext[0] === 0 ? 1 : ext[0];

    // one is neg and one is pos ==> check for larger of two and change one end
    } else {
      console.warn("log domain crosses 0, which is invalid");
      if(Math.abs(ext[0]) > Math.abs(ext[1])) {
        ext[1] = ext[1] === 0 ? -1 : ext[1];
      } else {
        ext[0] = ext[0] === 0 ? 1 : ext[0];
      }
    }

    return ext;

  }
},
  PxVisBehavior.sizing,
  PxVisBehaviorD3.axes,
  PxVisBehavior.dataset,
  PxVisBehavior.commonMethods,
  PxVisBehaviorD3.selectedDomain,
  PxVisBehavior.axisTypes,
  PxVisBehavior.completeSeriesConfig,
  PxVisBehavior.chartExtents,
  PxVisBehavior.dataExtents,
  PxVisBehaviorD3.domainUpdate,
  PxVisBehavior.preventWebWorkerSynchronization,
  PxVisBehavior.mutedSeries,
  PxVisBehavior.observerCheck,
  PxVisBehavior.scaleTypeCheck
];

</script>
